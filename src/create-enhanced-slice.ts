import { createSlice, isAnyOf } from '@reduxjs/toolkit';

import type { ActionReducerMapBuilder } from '@reduxjs/toolkit';
import type {
  SliceEnum,
  SliceState,
  ObjectKeys,
  SliceSelector,
  InitialStateSlice,
  ReturnType,
} from './types';

import { sliceSelectorString, sliceString } from './utils';
/**
 * Retrieves the key of an enum object based on its value.
 * @param {T} enumObject - Enum object of type `T` containing key-value pairs.
 * @param {string} value - The value of an enum member to find the corresponding key.
 * @returns The key of the enum object that matches the provided value, or `undefined` if not found.
 */
const getKeyFromEnumValue = <T extends object>(
  enumObject: T,
  value: string
) => {
  return Object.entries(enumObject).find(([_, v]) => v === value)?.[0];
};

/**
 * Creates an enum-like object with modified keys based on an initial key and a name.
 * @param {T} obj - Generic object of type `T` to create an enum from.
 * @param {K} initialKey - The starting key for the enumeration, of type `K`.
 * @param {S} name - String used as a prefix to create modified keys for the enum, of type `S`.
 * @returns An object of type `SliceEnum<K, S>` that maps keys of type `K` to their corresponding
 * modified keys of type `S`.
 */
const createEnumObject = <
  T extends unknown,
  K extends unknown,
  S extends string
>(
  obj: T,
  initialKey: K,
  name: S
): SliceEnum<K, S> => {
  const createModifiedKeys = (key: string) => ({
    [sliceString(name, key)]: key,
  });

  const processKeys = (accumulator: Record<string, unknown>, key: string) => {
    const modifiedKey = modifiedKeys.find((record) => record[key])[key];
    accumulator[key] = modifiedKey;
    accumulator[modifiedKey] = key;
    return accumulator;
  };

  const modifiedKeys = Object.keys(initialKey).map(createModifiedKeys);
  const result = Object.keys(obj).reduce(processKeys, Object.create(null));

  return Object.freeze(result);
};

/**
 * Modifies an initial state object by creating a new object with additional properties
 * based on the keys of the original object.
 * @param {T} state - Initial state of type `T` to be modified.
 * @param {S} name - Name of the slice to be created from the initial state, of type `S`.
 * @returns An object with properties containing keys generated by concatenating the `name` argument
 * with each key in the `state` object. The value of each property is an object with the following
 * properties: `results`, `isLoading`, `hasMore`, `page`, and `errors`.
 */
const createInitialStateSlice = <T, S extends string>(
  state: T,
  name: S
): InitialStateSlice<T, S> => {
  const createSliceState = (
    accumulator: Record<string, unknown>,
    key: string
  ) => {
    accumulator[sliceString(name, key)] = {
      results: state[key],
      isLoading: false,
      hasMore: true,
      page: 0,
      errors: null,
    };

    return accumulator;
  };

  return Object.keys(state).reduce(createSliceState, Object.create(null));
};

/**
 * Creates a Redux slice with standardized cases for handling asynchronous actions and
 * generates selectors for accessing the slice state.
 * @param {S} name - Name of the slice, used to identify it in the Redux store.
 * @param {T} initialState - Initial state of the slice.
 * @returns An object containing the created slice, `queryTypes`, and `selectors`.
 * `queryTypes` maps the initial state keys to string values, and `selectors` contains
 * selector functions for each key in the `queryTypes` object.
 *
 * @example
 * const { slice, queryTypes, selectors } = createEnhancedSlice('users', {
 *  users: [],
 *  user: null,
 * }, {
 *  cases: {
 *    pending: ['fetchUsers', 'fetchUser'],
 *  }
 * });
 *
 * const { fetchUsers, fetchUser } = slice.actions;
 * const { selectUsersUsers, selectUsersUser } = selectors;
 * const { users, user } = queryTypes;
 */
export const createEnhancedSlice = <S extends string, T extends unknown>(
  name: S,
  initialState: T,
  {
    reducers = {},
    extraReducers = (builder: ActionReducerMapBuilder<any>) => {},
    cases: { pending = [], fulfilled = [], rejected = [] } = {},
  },
  options?: { debug?: boolean; HYDRATE?: string }
) => {
  const createDebuggingMessage = (
    message,
    type: 'log' | 'error' | 'warn' = 'log'
  ) => {
    if (options?.debug) {
      console[type](
        `ðŸŒœ [createEnhancedSlice]: ${message[0]} ðŸŒ›`,
        ...message.slice(1)
      );
    }
  };

  const debugMessages = {
    INVALID_KEY: `Invalid key provided. The key must be one of the following:`,
    SLICE_CREATED: `created slices for ${name}:`,
    SELECTOR_CREATED: `composed selectors for ${name}:`,
  };

  const getInitialStateSlice = createInitialStateSlice(initialState, name);

  const queryTypeEnums = createEnumObject(
    getInitialStateSlice,
    initialState,
    name
  );

  createDebuggingMessage([debugMessages.SLICE_CREATED, getInitialStateSlice]);

  type QueryKey = typeof getInitialStateSlice & string;

  type ActionBuilder = ActionReducerMapBuilder<InitialStateSlice<T, S>>;
  type ComposeSelectorsReturnType = {
    [K in ObjectKeys<typeof queryTypeEnums> as SliceSelector<K, S>]: (
      s: any
    ) => SliceState<T[K]>;
  };

  const composeSelectors = (): ComposeSelectorsReturnType => {
    const createSelector = (
      accumulator: Record<string, unknown>,
      key: string
    ) => {
      const selectorName = sliceSelectorString(name, key);

      accumulator[selectorName] = (state: ReturnType<any>) => {
        return state[name][getKeyFromEnumValue(queryTypeEnums, key)];
      };

      return accumulator;
    };

    /* If the `debug` property in the `options` object is truthy,
     * logs a message to the console with information about the composed
     * selector for the slice, including the slice name and the result
     * of calling the `createSelector` function on each key in the
     * `initialState` object. Useful for debugging and development.
     */

    const composedSelectors = Object.keys(initialState).reduce(
      createSelector,
      {}
    );

    createDebuggingMessage([debugMessages.SELECTOR_CREATED, composedSelectors]);

    return Object.freeze(composedSelectors) as ComposeSelectorsReturnType;
  };

  const constructPendingCases = (builder: ActionBuilder, cases: any) => {
    return builder.addMatcher(
      isAnyOf(...cases.map((c: any) => c.matchPending)),
      (state, action) => {
        const key = action.meta.arg.originalArgs._queryType;
        const newState = state[key as QueryKey];

        if (key && getKeyFromEnumValue(queryTypeEnums, key)) {
          newState.isLoading = true;
        } else {
          createDebuggingMessage(
            [debugMessages.INVALID_KEY, Object.keys(initialState).join(', ')],
            'error'
          );
        }
      }
    );
  };

  const constructFailedCases = (builder: ActionBuilder, cases: any) => {
    return builder.addMatcher(
      isAnyOf(...cases.map((c: any) => c.matchRejected)),
      (state, action) => {
        const key = action.meta.arg.originalArgs._queryType;
        const newState = state[key as QueryKey];
        if (key && getKeyFromEnumValue(queryTypeEnums, key)) {
          newState.isLoading = false;
          newState.errors = action.payload;
        } else {
          createDebuggingMessage(
            [debugMessages.INVALID_KEY, Object.keys(initialState).join(', ')],
            'error'
          );
        }
      }
    );
  };

  const constructSuccessCases = (builder: ActionBuilder, cases: any) => {
    return builder.addMatcher(
      isAnyOf(...cases.map((c: any) => c.matchFulfilled)),
      (state, action) => {
        const key = action.meta.arg.originalArgs._queryType;
        const newState = state[key as QueryKey];

        if (key && getKeyFromEnumValue(queryTypeEnums, key)) {
          if (action.payload.results || action.payload.results.length) {
            const canConcat =
              action?.payload?.page > 1 && Array.isArray(newState.results);
            newState.results = canConcat
              ? [...newState.results, ...(action?.payload?.results as T[])]
              : action?.payload?.results;
            newState.hasMore = canConcat
              ? (action?.payload?.results as T[]).length > 0
              : false;

            if (action?.payload?.page) newState.page = action?.payload?.page;
          }

          newState.isLoading = false;
        } else {
          createDebuggingMessage(
            [debugMessages.INVALID_KEY, Object.keys(initialState).join(', ')],
            'error'
          );
        }
      }
    );
  };

  const slice = createSlice({
    name,
    initialState: {
      ...createInitialStateSlice(initialState, name),
    },
    reducers: {
      ...reducers,
      setPageData(
        state,
        action: {
          payload: {
            _queryType: keyof QueryKey;
            data: SliceState<T>;
          };
        }
      ) {
        const { _queryType: type, data } = action.payload;
        const newState = state[type as QueryKey];
        const canConcat = data?.page > 1 && Array.isArray(newState.results);
        newState.results = canConcat
          ? [...newState.results, ...(data?.results as T[])]
          : data?.results;

        newState.hasMore = canConcat
          ? (data?.results as T[]).length > 0
          : false;
        newState.isLoading = data.isLoading;

        if (data.errors) newState.errors = data.errors;
        if (data.page) newState.page = data.page;
      },
    },
    extraReducers: (builder) => {
      if (options?.HYDRATE) {
        builder.addCase(
          options?.HYDRATE,
          (state: ReturnType<any>, action: any) => {
            return {
              ...state,
              ...action.payload[name],
            };
          }
        );
      }

      extraReducers(builder);

      !!pending.length && constructPendingCases(builder, pending);
      !!rejected.length && constructFailedCases(builder, rejected);
      !!fulfilled.length && constructSuccessCases(builder, fulfilled);
    },
  });

  return {
    ...slice,
    queryTypes: {
      ...queryTypeEnums,
    },
    selectors: {
      ...composeSelectors(),
    },
  };
};

export default createEnhancedSlice;
